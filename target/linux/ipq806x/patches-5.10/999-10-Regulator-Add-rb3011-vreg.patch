diff -rNu a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
--- a/drivers/regulator/Kconfig	2022-10-06 08:42:26.678207322 +0300
+++ b/drivers/regulator/Kconfig	2022-10-06 10:36:05.588525407 +0300
@@ -1204,6 +1204,11 @@
 	  converters, 11 general purpose LDOs, VBUS generator and digital
 	  output to control regulators.
 
+config REGULATOR_RB3011
+	tristate "RouterBoard3011 voltage regulator"
+	help
+	  RB3011 voltge regulator
+
 config REGULATOR_TWL4030
 	tristate "TI TWL4030/TWL5030/TWL6030/TPS659x0 PMIC"
 	depends on TWL4030_CORE
diff -rNu a/drivers/regulator/Makefile b/drivers/regulator/Makefile
--- a/drivers/regulator/Makefile	2022-10-06 08:42:26.678207322 +0300
+++ b/drivers/regulator/Makefile	2022-10-06 10:34:32.251547570 +0300
@@ -146,6 +146,7 @@
 obj-$(CONFIG_REGULATOR_TPS65912) += tps65912-regulator.o
 obj-$(CONFIG_REGULATOR_TPS80031) += tps80031-regulator.o
 obj-$(CONFIG_REGULATOR_TPS65132) += tps65132-regulator.o
+obj-$(CONFIG_REGULATOR_RB3011) += vreg3011.o
 obj-$(CONFIG_REGULATOR_TWL4030) += twl-regulator.o twl6030-regulator.o
 obj-$(CONFIG_REGULATOR_UNIPHIER) += uniphier-regulator.o
 obj-$(CONFIG_REGULATOR_VCTRL) += vctrl-regulator.o
diff -rNu a/drivers/regulator/vreg3011.c b/drivers/regulator/vreg3011.c
--- a/drivers/regulator/vreg3011.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/regulator/vreg3011.c	2022-10-14 08:39:13.569086461 +0300
@@ -0,0 +1,301 @@
+// SPDX-License-Identifier: GPL-2.0+
+//
+// This code is based on Mikrotik GPL for RouterOS 7.x
+//
+// Copyright (c) 2021 Mikrotik <support@mikrotik.com>
+// Copyright (c) 2022 Serhii Serhieiev <adron@mstnt.com>
+//
+// Driver for TPS563900 CPUs voltage regulator for Mikrotik RB3011
+
+
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/slab.h>
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Serhii Serhieiev <adron@mstnt.com>");
+MODULE_DESCRIPTION("Mikrotik RB3011 CPUs voltage regulator");
+
+enum vreg3011_regs {
+	VOUT0_SEL  = 0x00,
+	VOUT1_SEL  = 0x01,
+	VOUT0_COM  = 0x02,
+	VOUT1_COM  = 0x03,
+	SYS_STATUS = 0x04,
+	CUR0_VOLT  = 0x0f,
+	CUR1_VOLT  = 0x10,
+	VREG_MAX	 = 0xff
+};
+
+#define VOLT_SEL_MASK 0x7f
+#define VOUT_GO_BIT BIT(7)
+#define DUMMY_VOUT_START 2
+
+struct vreg3011_priv {
+	unsigned vmin_uV;
+	unsigned vmax_uV;
+	unsigned step_uV;
+	unsigned output;
+	struct device *dev;
+	struct i2c_client *i2c_client;
+	struct regulator_dev *rdev;
+	struct regulator_desc *desc;
+	int last_voltage;
+};
+
+int rb3011_vreg_rxdata(struct i2c_client *client, char *rxdata,
+unsigned char reg, int length) {
+	int rc = 0;
+	unsigned short saddr = client->addr;
+	struct i2c_msg msgs[] = {
+		{
+			.addr  = saddr,
+			.flags = 0,
+			.len   = 1,
+			.buf   = (unsigned char *) &reg,
+		}, {
+			.addr  = saddr,
+			.flags = I2C_M_RD,
+			.len   = length,
+			.buf   = (unsigned char *) rxdata,
+		},
+	};
+
+	rc = i2c_transfer(client->adapter, msgs, 2);
+	if (rc < 0) {
+		dev_err(&client->dev, "rb3011_vreg_rxdata failed 0x%x (%d)\n", saddr, rc);
+	}
+	return rc;
+}
+
+int rb3011_vreg_txdata(struct i2c_client *client, char *txdata, int length) {
+	int rc = 0;
+	unsigned short saddr = client->addr;
+	struct i2c_msg msg[] = {
+		{
+			.addr = saddr,
+			.flags = 0,
+			.len = length,
+			.buf = (unsigned char *) txdata,
+		},
+	};
+
+	rc = i2c_transfer(client->adapter, msg, 1);
+	if (rc < 0) {
+		dev_err(&client->dev, "rb3011_vreg_txdata failed 0x%x (%d)\n", saddr, rc);
+	}
+	return rc;
+}
+
+static int rb3011_set_voltage_sel(struct regulator_dev *rdev,
+unsigned int volt_idx)
+{
+	int reg;
+	unsigned char data[2];
+	struct vreg3011_priv *priv = rdev->reg_data;
+	unsigned char output = (unsigned char)priv->output;
+
+	priv->last_voltage = volt_idx;
+	if (output >= DUMMY_VOUT_START) {
+		/* this is a dummy regulator output. actually it doesn't
+			 exist. only the first two are real! */
+		return 0;
+	}
+	reg = (output == 0) ? VOUT0_SEL : VOUT1_SEL;
+	data[0] = reg;
+	data[1] = (unsigned char)((volt_idx & VOLT_SEL_MASK) | VOUT_GO_BIT);
+	rb3011_vreg_txdata(priv->i2c_client, data, sizeof(data));
+	return 0;
+}
+
+static int rb3011_get_voltage_sel(struct regulator_dev *rdev)
+{
+	struct vreg3011_priv *priv = rdev->reg_data;
+	unsigned char output = (unsigned char)priv->output;
+	char volt_idx = 0;
+	int reg;
+
+	if (output >= DUMMY_VOUT_START) {
+		/* this is a dummy regulator output. actually it doesn't
+			 exist. only the first two are real! */
+		return priv->last_voltage;
+	}
+	reg = (output == 0) ? CUR0_VOLT : CUR1_VOLT;
+	rb3011_vreg_rxdata(priv->i2c_client, &volt_idx, reg, 1);
+	return volt_idx & VOLT_SEL_MASK;
+}
+
+static struct regulator_ops vreg3011_ops = {
+	.get_voltage_sel	= rb3011_get_voltage_sel,
+	.set_voltage_sel	= rb3011_set_voltage_sel,
+	.list_voltage	= regulator_list_voltage_linear,
+};
+
+static const struct of_device_id vreg3011_of_match[] = {
+	{ .compatible = "rb3011-regulator" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, vreg3011_of_match);
+
+struct rb3011_regulator_data {
+	int output_id;
+	struct regulator_desc desc;
+	struct vreg3011_priv *priv;
+};
+
+static struct rb3011_regulator_data reg_data0 = {
+	.output_id = 0,
+	.desc.of_match = of_match_ptr("cpu0vreg"),
+	.desc.name = "cpu0vreg",
+};
+static struct rb3011_regulator_data reg_data1 = {
+	.output_id = 1,
+	.desc.of_match = of_match_ptr("cpu1vreg"),
+	.desc.name = "cpu1vreg",
+};
+static struct rb3011_regulator_data reg_data2 = {
+	.output_id = 2,
+	.desc.of_match = of_match_ptr("l2vreg"),
+	.desc.name = "l2vreg",
+};
+static struct rb3011_regulator_data reg_data3 = {
+	.output_id = 3,
+	.desc.of_match = of_match_ptr("nssvreg"),
+	.desc.name = "nssvreg",
+};
+
+static struct of_regulator_match matches[] = {
+	{ .name = "cpu0vreg", .driver_data = &reg_data0 },
+	{ .name = "cpu1vreg", .driver_data = &reg_data1 },
+	{ .name = "l2vreg", .driver_data = &reg_data2 },
+	{ .name = "nssvreg", .driver_data = &reg_data3 },
+};
+
+#define NUM_MATCHES	sizeof(matches)/sizeof(struct of_regulator_match)
+
+static int vreg3011_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct device_node *np, *regulators;
+	int i, ret;
+
+	np = client->dev.of_node;
+	if (np) {
+		const struct of_device_id *match;
+		match = of_match_device(of_match_ptr(vreg3011_of_match),
+				&client->dev);
+		if (!match) {
+			dev_err(&client->dev, "Error: No device match found\n");
+			return -ENODEV;
+		}
+	}
+
+	regulators = of_get_child_by_name(np, "regulators");
+	if (!regulators) {
+		dev_err(&client->dev, "regulator node not found\n");
+		return 0;
+	}
+
+	ret = of_regulator_match(&client->dev, regulators, matches, NUM_MATCHES);
+	of_node_put(regulators);
+	if (ret < 0) {
+		dev_err(&client->dev, "Error parsing regulator init data: %d\n", ret);
+		return 0;
+	}
+
+	for (i = 0; i < NUM_MATCHES; i++) {
+		struct regulator_config config = { };
+		struct device_node *regulator_np;
+		struct of_regulator_match *match;
+		struct vreg3011_priv *priv;
+		struct rb3011_regulator_data *reg_data;
+		struct regulator_dev *rdev;
+
+		match = &matches[i];
+		regulator_np = match->of_node;
+
+		if (!regulator_np)
+			continue;
+
+		reg_data = (struct rb3011_regulator_data *)match->driver_data;
+
+		priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+		if (!priv)
+			return -ENOMEM;
+
+		of_property_read_u32(regulator_np, "regulator-min-microvolt", (unsigned*)&priv->vmin_uV);
+		of_property_read_u32(regulator_np, "regulator-max-microvolt", (unsigned*)&priv->vmax_uV);
+		of_property_read_u32(regulator_np, "regulator-step-microvolt", (unsigned*)&priv->step_uV);
+		of_property_read_u32(regulator_np, "regulator-output", (unsigned*)&priv->output);
+
+		priv->desc = &reg_data->desc;
+		priv->i2c_client = client;
+		priv->desc->id = 0;
+		priv->desc->min_uV = priv->vmin_uV;
+		priv->desc->uV_step = priv->step_uV;
+		priv->desc->linear_min_sel = 0;
+		priv->desc->n_voltages = 0x7f;
+		priv->desc->ops = &vreg3011_ops;
+		priv->desc->type = REGULATOR_VOLTAGE;
+		priv->desc->owner = THIS_MODULE;
+		priv->desc->vsel_reg = 0x0;
+		priv->desc->vsel_mask = 0x7f;
+
+		priv->output = reg_data->output_id;
+		priv->dev = &client->dev;
+
+		i2c_set_clientdata(client, priv);
+
+		config.dev = &client->dev;
+		config.init_data = match->init_data;
+		config.driver_data = priv;
+//		config.regmap = priv->regmap;
+		config.of_node = regulator_np;
+
+		rdev = devm_regulator_register(&client->dev, priv->desc, &config);
+		if (IS_ERR(rdev)) {
+			dev_err(&client->dev, "regulator register failed\n");
+			return PTR_ERR(rdev);
+		} else {
+			dev_info(&client->dev, "regulator %s registered\n", match->name);
+		}
+		reg_data->priv = priv;
+		priv->rdev = rdev;
+	}
+	return 0;
+}
+
+static const struct i2c_device_id vreg3011_id[] = {
+	{ .name = "rb3011-regulator" },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, vreg3011_id);
+
+static struct i2c_driver vreg3011_i2c_driver = {
+	.driver = {
+		.name = "rb3011-vreg",
+		.of_match_table = of_match_ptr(vreg3011_of_match),
+	},
+	.probe = vreg3011_probe,
+	.id_table = vreg3011_id,
+};
+
+static int __init vreg3011_init(void)
+{
+	return i2c_add_driver(&vreg3011_i2c_driver);
+}
+subsys_initcall(vreg3011_init);
+
+static void __exit vreg3011_cleanup(void)
+{
+	i2c_del_driver(&vreg3011_i2c_driver);
+}
+module_exit(vreg3011_cleanup);
