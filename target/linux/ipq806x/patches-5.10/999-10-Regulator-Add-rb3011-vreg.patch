diff -rNu a/drivers/regulator/Kconfig b/drivers/regulator/Kconfig
--- a/drivers/regulator/Kconfig	2022-10-06 08:42:26.678207322 +0300
+++ b/drivers/regulator/Kconfig	2022-10-06 10:36:05.588525407 +0300
@@ -1204,6 +1204,11 @@
 	  converters, 11 general purpose LDOs, VBUS generator and digital
 	  output to control regulators.
 
+config REGULATOR_RB3011
+	tristate "RouterBoard3011 voltage regulator"
+	help
+	  RB3011 voltge regulator
+
 config REGULATOR_TWL4030
 	tristate "TI TWL4030/TWL5030/TWL6030/TPS659x0 PMIC"
 	depends on TWL4030_CORE
diff -rNu a/drivers/regulator/Makefile b/drivers/regulator/Makefile
--- a/drivers/regulator/Makefile	2022-10-06 08:42:26.678207322 +0300
+++ b/drivers/regulator/Makefile	2022-10-06 10:34:32.251547570 +0300
@@ -146,6 +146,7 @@
 obj-$(CONFIG_REGULATOR_TPS65912) += tps65912-regulator.o
 obj-$(CONFIG_REGULATOR_TPS80031) += tps80031-regulator.o
 obj-$(CONFIG_REGULATOR_TPS65132) += tps65132-regulator.o
+obj-$(CONFIG_REGULATOR_RB3011) += vreg3011.o
 obj-$(CONFIG_REGULATOR_TWL4030) += twl-regulator.o twl6030-regulator.o
 obj-$(CONFIG_REGULATOR_UNIPHIER) += uniphier-regulator.o
 obj-$(CONFIG_REGULATOR_VCTRL) += vctrl-regulator.o
diff -rNu a/drivers/regulator/vreg3011.c b/drivers/regulator/vreg3011.c
--- a/drivers/regulator/vreg3011.c	1970-01-01 03:00:00.000000000 +0300
+++ b/drivers/regulator/vreg3011.c	2022-10-06 10:28:04.606562388 +0300
@@ -0,0 +1,265 @@
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/machine.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/slab.h>
+
+enum vreg3011_regs {
+	VOUT0_SEL = 0x0,
+	VOUT1_SEL = 0x1,
+	VOUT0_COM = 0x2,
+	VOUT1_COM = 0x3,
+	SYS_STATUS = 0x4,
+	VREG3011_MAX,
+};
+
+struct vreg3011_priv {
+	unsigned vmin_uV;
+	unsigned vmax_uV;
+	unsigned step_uV;
+	unsigned output;
+	struct device *dev;
+	struct i2c_client *i2c_client;
+	struct regulator_dev *rdev;
+	struct regulator_desc *desc
+};
+
+int rb3011_vreg_rxdata(struct i2c_client *client, char *rxdata, int length) {
+    int rc = 0;
+    unsigned short saddr = client->addr;
+    struct i2c_msg msgs[] = {
+	{
+	    .addr  = saddr,
+	    .flags = 0,
+	    .len   = 1,
+	    .buf   = (unsigned char *) rxdata,
+	},
+	{
+	    .addr  = saddr,
+	    .flags = I2C_M_RD,
+	    .len   = length,
+	    .buf   = (unsigned char *) rxdata,
+	},
+    };
+    rc = i2c_transfer(client->adapter, msgs, 2);
+    if (rc < 0) printk("rb3011_vreg_rxdata failed 0x%x (%d)\n", saddr, rc);
+    return rc;
+}
+
+int rb3011_vreg_txdata(struct i2c_client *client, char *txdata, int length) {
+    int rc = 0;
+    unsigned short saddr = client->addr;
+    struct i2c_msg msg[] = {
+	{
+	    .addr = saddr,
+	    .flags = 0,
+	    .len = length,
+	    .buf = (unsigned char *) txdata,
+	},
+    };
+    rc = i2c_transfer(client->adapter, msg, 1);
+    if (rc < 0) printk("rb3011_vreg_txdata failed 0x%x (%d)\n", saddr, rc);
+    return rc;
+}
+
+
+static unsigned char  convert_voltage(struct vreg3011_priv *priv, int uV) {
+    if (uV < priv->vmin_uV) {
+	return 0x00;
+    }
+    else if (uV > priv->vmax_uV) {
+	return 0x7f;
+    }
+    else {
+	return (uV - priv->vmin_uV) / priv->step_uV;
+    }
+}
+
+
+static int rb3011_set_voltage_sel(struct regulator_dev *rdev,
+						unsigned int sel)
+{
+	struct vreg3011_priv *priv = rdev->reg_data;
+	unsigned char output = (unsigned char)priv->output;
+	unsigned char data[2];
+	data[0] = output;
+	data[1] =  (unsigned char)((sel & 0x7f) | (1 << 7));
+	rb3011_vreg_txdata(priv->i2c_client, data, sizeof(data));
+	return 0;
+}
+
+static int rb3011_get_voltage_sel(struct regulator_dev *rdev)
+{
+	struct vreg3011_priv *priv = rdev->reg_data;
+	unsigned char output = (unsigned char)priv->output;
+	char rxdata, txdata;
+	rb3011_vreg_txdata(priv->i2c_client, &txdata, 1);
+	rb3011_vreg_rxdata(priv->i2c_client, &rxdata, 1);
+	return rxdata & 0x7f;
+}
+
+static struct regulator_ops vreg3011_ops = {
+	.get_voltage_sel	= rb3011_get_voltage_sel,
+	.set_voltage_sel	= rb3011_set_voltage_sel,
+	.list_voltage		= regulator_list_voltage_linear,
+//	.set_voltage_time_sel	= regulator_set_voltage_time_sel,
+//	.set_ramp_delay		= vreg3011_dcdc_set_ramp_delay,
+};
+
+static const struct of_device_id vreg3011_of_match[] = {
+	{ .compatible = "rb3011-regulator" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, vreg3011_of_match);
+
+struct rb3011_regulator_data {
+	int output_id;
+	struct regulator_desc desc; 
+	struct vreg3011_priv *priv;
+};
+
+static struct rb3011_regulator_data reg_data0 = {
+	.output_id = 0,
+	.desc.of_match = of_match_ptr("cpu0vreg"),
+	.desc.name = "cpu0vreg",
+};
+static struct rb3011_regulator_data reg_data1 = {
+	.output_id = 1,
+	.desc.of_match = of_match_ptr("cpu1vreg"),
+	.desc.name = "cpu1vreg",
+};
+
+static struct of_regulator_match matches[] = {
+	{ .name = "cpu0vreg", .driver_data = &reg_data0 },
+	{ .name = "cpu1vreg", .driver_data = &reg_data1 },
+};
+
+#define NUM_MATCHES	sizeof(matches)/sizeof(struct of_regulator_match)
+
+static int vreg3011_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct device_node *np, *regulators;
+	int i, ret;
+
+	np = client->dev.of_node;
+	if (np) {
+		const struct of_device_id *match;
+		match = of_match_device(of_match_ptr(vreg3011_of_match),
+				&client->dev);
+		if (!match) {
+			dev_err(&client->dev, "Error: No device match found\n");
+			return -ENODEV;
+		}
+	}
+
+	regulators = of_get_child_by_name(np, "regulators");
+	if (!regulators) {
+		dev_err(&client->dev, "regulator node not found\n");
+		return 0;
+	}
+
+	ret = of_regulator_match(&client->dev, regulators, matches, NUM_MATCHES);
+	of_node_put(regulators);
+	if (ret < 0) {
+		dev_err(&client->dev, "Error parsing regulator init data: %d\n", ret);
+		return 0;
+	}
+
+	for (i = 0; i < NUM_MATCHES; i++) {
+		struct regulator_config config = { };
+		struct device_node *regulator_np;
+		struct of_regulator_match *match;
+		struct vreg3011_priv *priv;
+		struct rb3011_regulator_data *reg_data;
+		struct regulator_dev *rdev;
+
+		struct palmas_reg_init *rinit;
+		struct device_node *np;
+
+		match = &matches[i];
+		regulator_np = match->of_node;
+
+		if (!regulator_np)
+			continue;
+
+		reg_data = (struct rb3011_regulator_data *)match->driver_data;
+
+		priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+		if (!priv)
+			return -ENOMEM;
+
+		of_property_read_u32(regulator_np, "regulator-min-microvolt", (unsigned*)&priv->vmin_uV);
+		of_property_read_u32(regulator_np, "regulator-max-microvolt", (unsigned*)&priv->vmax_uV);
+		of_property_read_u32(regulator_np, "regulator-step-microvolt", (unsigned*)&priv->step_uV);
+		of_property_read_u32(regulator_np, "regulator-output", (unsigned*)&priv->output);
+
+		priv->desc = &reg_data->desc;
+		priv->i2c_client = client;
+		priv->desc->id = 0;
+		priv->desc->min_uV = priv->vmin_uV;
+		priv->desc->uV_step = priv->step_uV;
+		priv->desc->linear_min_sel = 0;
+		priv->desc->n_voltages = 0x7f;
+		priv->desc->ops = &vreg3011_ops;
+		priv->desc->type = REGULATOR_VOLTAGE;
+		priv->desc->owner = THIS_MODULE;
+		priv->desc->vsel_reg = 0x0;
+		priv->desc->vsel_mask = 0x7f;
+
+		priv->output = reg_data->output_id;
+		priv->dev = &client->dev;
+
+		i2c_set_clientdata(client, priv);
+
+		config.dev = &client->dev;
+		config.init_data = match->init_data;
+		config.driver_data = priv;
+//		config.regmap = priv->regmap;
+		config.of_node = regulator_np;
+
+		rdev = devm_regulator_register(&client->dev, priv->desc, &config);
+		if (IS_ERR(rdev)) {
+			dev_err(&client->dev, "regulator register failed\n");
+			return PTR_ERR(rdev);
+		} else {
+			dev_info(&client->dev, "regulator %s registered\n", match->name);
+		}
+		reg_data->priv = priv;
+		priv->rdev = rdev;
+	}
+	return 0;
+}
+
+static const struct i2c_device_id vreg3011_id[] = {
+	{ .name = "rb3011-regulator" },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, vreg3011_id);
+
+static struct i2c_driver vreg3011_i2c_driver = {
+	.driver = {
+		.name = "rb3011-vreg",
+		.of_match_table = of_match_ptr(vreg3011_of_match),
+	},
+	.probe = vreg3011_probe,
+	.id_table = vreg3011_id,
+};
+
+static int __init vreg3011_init(void)
+{
+	return i2c_add_driver(&vreg3011_i2c_driver);
+}
+subsys_initcall(vreg3011_init);
+
+static void __exit vreg3011_cleanup(void)
+{
+	i2c_del_driver(&vreg3011_i2c_driver);
+}
+module_exit(vreg3011_cleanup);
