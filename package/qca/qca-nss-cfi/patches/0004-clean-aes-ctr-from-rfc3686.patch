diff -rNu a/cryptoapi/v1.1/nss_cryptoapi_ablk.c b/cryptoapi/v1.1/nss_cryptoapi_ablk.c
--- a/cryptoapi/v1.1/nss_cryptoapi_ablk.c	2022-10-24 14:46:15.830241481 +0300
+++ b/cryptoapi/v1.1/nss_cryptoapi_ablk.c	2022-10-24 16:28:46.278971714 +0300
@@ -212,20 +212,8 @@
 	/*
 	 * check for the algorithm
 	 */
-	if (!strncmp("nss-rfc3686-ctr-aes", crypto_tfm_alg_driver_name(tfm), CRYPTO_MAX_ALG_NAME)) {
+	if (!strncmp("nss-ctr-aes", crypto_tfm_alg_driver_name(tfm), CRYPTO_MAX_ALG_NAME)) {
 		cip.algo = NSS_CRYPTO_CIPHER_AES_CTR;
-
-		/*
-		 * For RFC3686 CTR mode we construct the IV such that
-		 * - First word is key nonce
-		 * - Second & third word set to the IV provided by seqiv
-		 * - Last word set to counter '1'
-		 */
-		cip.key_len = cip.key_len - CTR_RFC3686_NONCE_SIZE;
-
-		ctx->ctx_iv[0] = *(uint32_t *)(cip.key + cip.key_len);
-		ctx->ctx_iv[3] = ntohl(0x1);
-
 	} else if (!strncmp("nss-cbc-aes", crypto_tfm_alg_driver_name(tfm), CRYPTO_MAX_ALG_NAME)) {
 		cip.algo = NSS_CRYPTO_CIPHER_AES_CBC;
 	} else
@@ -424,17 +412,11 @@
 
 	switch (ctx->cip_alg) {
 	case NSS_CRYPTO_CIPHER_AES_CBC:
+	case NSS_CRYPTO_CIPHER_AES_CTR:
 	case NSS_CRYPTO_CIPHER_DES:
 		memcpy(iv_addr, req->iv, iv_size);
 		break;
 
-	case NSS_CRYPTO_CIPHER_AES_CTR:
-		((uint32_t *)iv_addr)[0] = ctx->ctx_iv[0];
-		((uint32_t *)iv_addr)[1] = ((uint32_t *)req->iv)[0];
-		((uint32_t *)iv_addr)[2] = ((uint32_t *)req->iv)[1];
-		((uint32_t *)iv_addr)[3] = ctx->ctx_iv[3];
-		break;
-
 	default:
 		/*
 		 * Should never happen
@@ -502,7 +484,7 @@
 
 /*
  * nss_cryptoapi_ablk_aes_encrypt()
- * 	Crytoapi encrypt for aes(aes-cbc/rfc3686-aes-ctr) algorithms.
+ * 	Crytoapi encrypt for aes(aes-cbc/aes-ctr) algorithms.
  */
 int nss_cryptoapi_ablk_aes_encrypt(struct skcipher_request *req)
 {
@@ -535,11 +517,7 @@
 		return -EINVAL;
 	}
 
-	/*
-	 * According to RFC3686, AES-CTR algo need not be padded if the
-	 * plaintext or ciphertext is unaligned to block size boundary.
-	 */
-	if (nss_cryptoapi_check_unalign(req->cryptlen, AES_BLOCK_SIZE) && (ctx->cip_alg != NSS_CRYPTO_CIPHER_AES_CTR)) {
+	if (nss_cryptoapi_check_unalign(req->cryptlen, AES_BLOCK_SIZE)) {
 		nss_cfi_err("Invalid cipher len - Not aligned to algo blocksize\n");
 		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
 		return -EINVAL;
@@ -569,7 +547,7 @@
 
 /*
  * nss_cryptoapi_ablk_aes_decrypt()
- * 	Crytoapi decrypt for aes(aes-cbc/rfc3686-aes-ctr) algorithms.
+ * 	Crytoapi decrypt for aes(aes-cbc/aes-ctr) algorithms.
  */
 int nss_cryptoapi_ablk_aes_decrypt(struct skcipher_request *req)
 {
@@ -602,11 +580,7 @@
 		return -EINVAL;
 	}
 
-	/*
-	 * According to RFC3686, AES-CTR algo need not be padded if the
-	 * plaintext or ciphertext is unaligned to block size boundary.
-	 */
-	if (nss_cryptoapi_check_unalign(req->cryptlen, AES_BLOCK_SIZE) && (ctx->cip_alg != NSS_CRYPTO_CIPHER_AES_CTR)) {
+	if (nss_cryptoapi_check_unalign(req->cryptlen, AES_BLOCK_SIZE)) {
 		nss_cfi_err("Invalid cipher len - Not aligned to algo blocksize\n");
 		crypto_skcipher_set_flags(cipher, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
 		return -EINVAL;
diff -rNu a/cryptoapi/v1.1/nss_cryptoapi_aead.c b/cryptoapi/v1.1/nss_cryptoapi_aead.c
--- a/cryptoapi/v1.1/nss_cryptoapi_aead.c	2022-10-24 14:46:15.830241481 +0300
+++ b/cryptoapi/v1.1/nss_cryptoapi_aead.c	2022-10-24 16:13:23.788073650 +0300
@@ -243,11 +243,11 @@
 	/*
 	 * check for the algorithm
 	 */
-	if (!strncmp("nss-hmac-sha256-rfc3686-ctr-aes", crypto_tfm_alg_driver_name(tfm), CRYPTO_MAX_ALG_NAME)) {
+	if (!strncmp("nss-hmac-sha256-ctr-aes", crypto_tfm_alg_driver_name(tfm), CRYPTO_MAX_ALG_NAME)) {
 		cip.algo = NSS_CRYPTO_CIPHER_AES_CTR;
 		auth.algo = NSS_CRYPTO_AUTH_SHA256_HMAC;
 		ctr_mode = true;
-	} else if (!strncmp("nss-hmac-sha1-rfc3686-ctr-aes", crypto_tfm_alg_driver_name(tfm), CRYPTO_MAX_ALG_NAME)) {
+	} else if (!strncmp("nss-hmac-sha1-ctr-aes", crypto_tfm_alg_driver_name(tfm), CRYPTO_MAX_ALG_NAME)) {
 		cip.algo = NSS_CRYPTO_CIPHER_AES_CTR;
 		auth.algo = NSS_CRYPTO_AUTH_SHA1_HMAC;
 		ctr_mode = true;
@@ -264,19 +264,6 @@
 	}
 
 	/*
-	 * For RFC3686 CTR mode we construct the IV such that
-	 * - First word is key nonce
-	 * - Second & third word set to the IV provided by seqiv
-	 * - Last word set to counter '1'
-	 */
-	if (ctr_mode) {
-		cip.key_len = cip.key_len - CTR_RFC3686_NONCE_SIZE;
-
-		ctx->ctx_iv[0] = *(uint32_t *)(cip.key + cip.key_len);
-		ctx->ctx_iv[3] = ntohl(0x1);
-	}
-
-	/*
 	 * This should never happen
 	 */
 	BUG_ON(!ctr_mode && !cbc_mode);
@@ -716,11 +703,7 @@
 
 	nss_cfi_assert(ctx);
 
-	/*
-	 * According to RFC3686, AES-CTR algo need not be padded if the
-	 * plaintext or ciphertext is unaligned to block size boundary.
-	 */
-	if ((info->cip_len & (crypto_aead_blocksize(aead) - 1)) && (ctx->cip_alg != NSS_CRYPTO_CIPHER_AES_CTR)) {
+	if ((info->cip_len & (crypto_aead_blocksize(aead) - 1))) {
 		nss_cfi_dbg("Invalid cipher len - Not aligned to algo blocksize\n");
 		crypto_aead_set_flags(aead, CRYPTO_TFM_RES_BAD_BLOCK_LEN);
 		return NULL;
@@ -862,7 +845,7 @@
 
 /*
  * nss_cryptoapi_aead_aes_encrypt()
- * 	Crytoapi common encrypt for aead aes (sha1/sha256 with aes-cbc/rfc3686-aes-ctr) algorithms.
+ * 	Crytoapi common encrypt for aead aes (sha1/sha256 with aes-cbc/aes-ctr) algorithms.
  */
 int nss_cryptoapi_aead_aes_encrypt(struct aead_request *req)
 {
@@ -929,7 +912,7 @@
 
 /*
  * nss_cryptoapi_aead_aes_decrypt()
- * 	Crytoapi common decrypt for aead aes (sha1/sha256 with aes-cbc/rfc3686-aes-ctr) algorithms.
+ * 	Crytoapi common decrypt for aead aes (sha1/sha256 with aes-cbc/aes-ctr) algorithms.
  */
 int nss_cryptoapi_aead_aes_decrypt(struct aead_request *req)
 {
diff -rNu a/cryptoapi/v1.1/nss_cryptoapi.c b/cryptoapi/v1.1/nss_cryptoapi.c
--- a/cryptoapi/v1.1/nss_cryptoapi.c	2022-10-24 14:46:15.830241481 +0300
+++ b/cryptoapi/v1.1/nss_cryptoapi.c	2022-10-24 16:11:16.243160419 +0300
@@ -82,10 +82,10 @@
 		.encrypt = nss_cryptoapi_aead_aes_encrypt,
 		.decrypt = nss_cryptoapi_aead_aes_decrypt,
 	},
-	{	/* sha1, rfc3686-aes-ctr */
+	{	/* sha1, aes-ctr */
 		.base = {
-			.cra_name       = "seqiv(authenc(hmac(sha1),rfc3686(ctr(aes))))",
-			.cra_driver_name = "nss-hmac-sha1-rfc3686-ctr-aes",
+			.cra_name       = "seqiv(authenc(hmac(sha1),ctr(aes)))",
+			.cra_driver_name = "nss-hmac-sha1-ctr-aes",
 			.cra_priority   = 10000,
 			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_NEED_FALLBACK | CRYPTO_ALG_KERN_DRIVER_ONLY,
 			.cra_blocksize  = AES_BLOCK_SIZE,
@@ -96,7 +96,7 @@
 
 		.init		= nss_cryptoapi_aead_init,
 		.exit		= nss_cryptoapi_aead_exit,
-		.ivsize         = CTR_RFC3686_IV_SIZE,
+		.ivsize         = AES_BLOCK_SIZE,
 		.maxauthsize    = SHA1_DIGEST_SIZE,
 		.setkey = nss_cryptoapi_aead_aes_setkey,
 		.setauthsize = nss_cryptoapi_aead_setauthsize,
@@ -145,10 +145,10 @@
 		.encrypt = nss_cryptoapi_aead_aes_encrypt,
 		.decrypt = nss_cryptoapi_aead_aes_decrypt,
 	},
-	{	/* sha256, rfc3686-aes-ctr */
+	{	/* sha256, aes-ctr */
 		.base = {
-			.cra_name       = "seqiv(authenc(hmac(sha256),rfc3686(ctr(aes))))",
-			.cra_driver_name = "nss-hmac-sha256-rfc3686-ctr-aes",
+			.cra_name       = "seqiv(authenc(hmac(sha256),ctr(aes)))",
+			.cra_driver_name = "nss-hmac-sha256-ctr-aes",
 			.cra_priority   = 10000,
 			.cra_flags      = CRYPTO_ALG_ASYNC | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_NEED_FALLBACK | CRYPTO_ALG_KERN_DRIVER_ONLY,
 			.cra_blocksize  = AES_BLOCK_SIZE,
@@ -159,7 +159,7 @@
 
 		.init		= nss_cryptoapi_aead_init,
 		.exit		= nss_cryptoapi_aead_exit,
-		.ivsize         = CTR_RFC3686_IV_SIZE,
+		.ivsize         = AES_BLOCK_SIZE,
 		.maxauthsize    = SHA256_DIGEST_SIZE,
 		.setkey = nss_cryptoapi_aead_aes_setkey,
 		.setauthsize = nss_cryptoapi_aead_setauthsize,
@@ -215,8 +215,8 @@
 	},
 	{
 		.base = {
-			.cra_name       = "rfc3686(ctr(aes))",
-			.cra_driver_name = "nss-rfc3686-ctr-aes",
+			.cra_name       = "ctr(aes)",
+			.cra_driver_name = "nss-ctr-aes",
 			.cra_priority   = 30000,
 			.cra_flags      = CRYPTO_ALG_TYPE_SKCIPHER | CRYPTO_ALG_NOSUPP_SG | CRYPTO_ALG_ASYNC | CRYPTO_ALG_NEED_FALLBACK | CRYPTO_ALG_KERN_DRIVER_ONLY,
 			.cra_blocksize  = AES_BLOCK_SIZE,
@@ -226,9 +226,9 @@
 		},
 		.init       = nss_cryptoapi_skcipher_init,
 		.exit       = nss_cryptoapi_skcipher_exit,
-		.ivsize         = CTR_RFC3686_IV_SIZE,
-		.min_keysize    = AES_MIN_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
-		.max_keysize    = AES_MAX_KEY_SIZE + CTR_RFC3686_NONCE_SIZE,
+		.ivsize         = AES_BLOCK_SIZE,
+		.min_keysize    = AES_MIN_KEY_SIZE,
+		.max_keysize    = AES_MAX_KEY_SIZE,
 		.setkey         = nss_cryptoapi_ablk_aes_setkey,
 		.encrypt        = nss_cryptoapi_ablk_aes_encrypt,
 		.decrypt        = nss_cryptoapi_ablk_aes_decrypt,
